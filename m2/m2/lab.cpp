/*
ГОСТ 28147-89
256-битный ключ шифрования и 32 цикла преобразования 64-битных блоков исходного сообщения

Сначала правая половина блока и ключ раунда складываются по модулю 2^32.
Результат сложения разбивается на восемь 4-битовых последовательностей, каждая из которых поступает на вход соответствующего S-блока
Каждый блок представляет собой таблицу подстановки, которая заменяет поступающее на вход число в диапазоне [0..15] на другое число в этом диапазоне
Выходы всех S-блоков объединяются в в 32-битное слово, которое затем циклически сдвигается влево на 11 битов и
объединяется с левой частью блока операцией XOR

Формирование ключей раунда осуществляется по простой схеме
256-битный ключ разбивается на восемь 32-битных машинныхслова
Они нумеруются с К0 по К7
32 ключа раунда получаются применением этих машинных слов в след порядке
К0 К1 К2 ... К7
-//-
К7 К6 К5 ... К0 - т.е. в последних 8 раундах ключи подаются в обр порядке

*/

#define _CRT_SECURE_NO_WARNINGS
#include <conio.h>
#include <iostream>
#include <tchar.h>
#include <stdio.h>

#define OPENFILE        "text.txt"
#define CRYPTEDFILE     "code.txt"
#define DECRYPTEDFILE   "decode.txt"

#define SEKRETKEY       "98765432109876543210987654321098" //32

#define CRYPT           false
#define DECRYPT         true

using namespace std;

void GOST(bool mode)
{
	//таблица с S-блоками алгоритма
	unsigned int Sbox[8][16] =
	{
		{  4, 10,  9,  2, 13,  8,  0, 14,  6, 11,  1, 12,  7, 15,  5,  3 },
		{ 14, 11,  4, 12,  6, 13, 15, 10,  2,  3,  8,  1,  0,  7,  5,  9 },
		{  5,  8,  1, 13, 10,  3,  4,  2, 14, 15, 12,  7,  6,  0,  9, 11 },
		{  7, 13, 10,  1,  0,  8,  9, 15, 14,  4,  6, 12, 11,  2,  5,  3 },
		{  6, 12,  7,  1,  5, 15, 13,  8,  4, 10,  9, 14,  0,  3, 11,  2 },
		{  4, 11, 10,  0,  7,  2,  1, 13,  3,  6,  8,  5,  9, 12, 15, 14 },
		{ 13, 11,  4,  1,  3, 15,  5,  9,  0, 10, 14,  7,  6,  8,  2, 12 },
		{  1, 15, 13,  0,  5,  7, 10,  4,  9,  2,  3, 14,  6, 11,  8, 12 }
	};

	//Ключ шифрования и его разбиение
	char s[33] = SEKRETKEY;
	unsigned int key[8];

	for (int i = 0; i < 8; i++)
	{
		// Сложение каждых 4-х символов ключа в одно число
		key[i] = (s[4 * i] << 24) + (s[1 + 4 * i] << 16) + (s[2 + 4 * i] << 8) + s[3 + 4 * i];

		key[i] =                        // Реверсирование битов
			((key[i] & 0x1) << 31) + ((key[i] & 0x2) << 29) + ((key[i] & 0x4) << 27) + ((key[i] & 0x8) << 25) +
			((key[i] & 0x10) << 23) + ((key[i] & 0x20) << 21) + ((key[i] & 0x40) << 19) + ((key[i] & 0x80) << 17) +
			((key[i] & 0x100) << 15) + ((key[i] & 0x200) << 13) + ((key[i] & 0x400) << 11) + ((key[i] & 0x800) << 9) +
			((key[i] & 0x1000) << 7) + ((key[i] & 0x2000) << 5) + ((key[i] & 0x4000) << 3) + ((key[i] & 0x8000) << 1) +
			((key[i] & 0x10000) >> 1) + ((key[i] & 0x20000) >> 3) + ((key[i] & 0x40000) >> 5) + ((key[i] & 0x80000) >> 7) +
			((key[i] & 0x100000) >> 9) + ((key[i] & 0x200000) >> 11) + ((key[i] & 0x400000) >> 13) + ((key[i] & 0x800000) >> 15) +
			((key[i] & 0x1000000) >> 17) + ((key[i] & 0x2000000) >> 19) + ((key[i] & 0x4000000) >> 21) + ((key[i] & 0x8000000) >> 23) +
			((key[i] & 0x10000000) >> 25) + ((key[i] & 0x20000000) >> 27) + ((key[i] & 0x40000000) >> 29) + ((key[i] & 0x80000000) >> 31);
	}

	// Работа с файлами
	FILE* f = fopen("text1.txt", "rb");	// Входной файл
	FILE* g = fopen("text2.txt", "wb"); // Выходной файл
	int fsize;							// Размер входного файла

	if (mode == CRYPT) //если шифр
	{
		f = fopen(OPENFILE, "rb");		// Файл для чтения исх текста
		fseek(f, 0, SEEK_END);			// Вычисление размера файла
		fsize = ftell(f);
		fseek(f, 0, SEEK_SET);
		g = fopen(CRYPTEDFILE, "wb");	// Файл для записи шифр текста
	}
	if (mode == DECRYPT) //если дешифр
	{
		f = fopen(CRYPTEDFILE, "rb");	// Файл для чтения шифр текста
		fseek(f, 0, SEEK_END);			// Вычисление размера файла
		fsize = ftell(f);
		fseek(f, 0, SEEK_SET);
		g = fopen(DECRYPTEDFILE, "wb");	// Файл для записи дешифр текста
	}

	// Основной цикл шифрования
	while (fsize)
	{
		unsigned int A = 0;						// Старший 32-битный блок
		unsigned int B = 0;						// Младший 32-битный блок

		for (int i = 0; i < 4; i++)				// Заполнение старшего блока...
		{
			if (fsize)
			{
				unsigned int s = 0;
				fread(&s, 1, 1, f);

				A += (s << (24 - (i * 8)));		// ...символами...
				fsize--;
			}
			else A += (32 << (24 - (i * 8)));	// ... или пробелами, если символы кончились, 
		}                                       //     а 64 бита еще не набралось
		//------------------------------------
		for (int i = 0; i < 4; i++)				// Заполнение младшего блока...
		{
			if (fsize)
			{
				unsigned int s = 0;
				fread(&s, 1, 1, f);

				B += (s << (24 - (i * 8)));		// ...символами...
				fsize--;
			}
			else B += (32 << (24 - (i * 8)));	// ... или пробелами, если символы кончились,
		}                                       //     а 64 бита еще не набралось

		A =                             // Реверсирование битов
			((A & 0x1) << 31) + ((A & 0x2) << 29) + ((A & 0x4) << 27) + ((A & 0x8) << 25) +
			((A & 0x10) << 23) + ((A & 0x20) << 21) + ((A & 0x40) << 19) + ((A & 0x80) << 17) +
			((A & 0x100) << 15) + ((A & 0x200) << 13) + ((A & 0x400) << 11) + ((A & 0x800) << 9) +
			((A & 0x1000) << 7) + ((A & 0x2000) << 5) + ((A & 0x4000) << 3) + ((A & 0x8000) << 1) +
			((A & 0x10000) >> 1) + ((A & 0x20000) >> 3) + ((A & 0x40000) >> 5) + ((A & 0x80000) >> 7) +
			((A & 0x100000) >> 9) + ((A & 0x200000) >> 11) + ((A & 0x400000) >> 13) + ((A & 0x800000) >> 15) +
			((A & 0x1000000) >> 17) + ((A & 0x2000000) >> 19) + ((A & 0x4000000) >> 21) + ((A & 0x8000000) >> 23) +
			((A & 0x10000000) >> 25) + ((A & 0x20000000) >> 27) + ((A & 0x40000000) >> 29) + ((A & 0x80000000) >> 31);

		B =                             // Реверсирование битов
			((B & 0x1) << 31) + ((B & 0x2) << 29) + ((B & 0x4) << 27) + ((B & 0x8) << 25) +
			((B & 0x10) << 23) + ((B & 0x20) << 21) + ((B & 0x40) << 19) + ((B & 0x80) << 17) +
			((B & 0x100) << 15) + ((B & 0x200) << 13) + ((B & 0x400) << 11) + ((B & 0x800) << 9) +
			((B & 0x1000) << 7) + ((B & 0x2000) << 5) + ((B & 0x4000) << 3) + ((B & 0x8000) << 1) +
			((B & 0x10000) >> 1) + ((B & 0x20000) >> 3) + ((B & 0x40000) >> 5) + ((B & 0x80000) >> 7) +
			((B & 0x100000) >> 9) + ((B & 0x200000) >> 11) + ((B & 0x400000) >> 13) + ((B & 0x800000) >> 15) +
			((B & 0x1000000) >> 17) + ((B & 0x2000000) >> 19) + ((B & 0x4000000) >> 21) + ((B & 0x8000000) >> 23) +
			((B & 0x10000000) >> 25) + ((B & 0x20000000) >> 27) + ((B & 0x40000000) >> 29) + ((B & 0x80000000) >> 31);

		unsigned int T;		// Для промежуточных вычислений

		// 32 раунда
		for (int i = 0; i < 32; i++)
		{
			T = 0;
			if (mode == CRYPT) // если шифр
			{
				if (i < 24) T = (A + key[i % 8]) % 0x100000000;		// суммирование с ключом в зависимости от раунда
				else T = (A + key[7 - (i % 8)]) % 0x100000000;
			}
			if (mode == DECRYPT) // если дешифр
			{
				if (i < 8) T = (A + key[i % 8]) % 0x100000000;		// суммирование с ключом в зависимости от раунда
				else T = (A + key[7 - (i % 8)]) % 0x100000000;
			}

			unsigned int Fragments[8] =     // Разбиение на 4-битные фрагменты
			{
				(T & 0xF0000000) >> 28,
				(T & 0xF000000) >> 24,
				(T & 0xF00000) >> 20,
				(T & 0xF0000) >> 16,
				(T & 0xF000) >> 12,
				(T & 0xF00) >> 8,
				(T & 0xF0) >> 4,
				(T & 0xF)
			};

			for (int j = 0; j < 8; j++)
			{
				Fragments[j] = Sbox[j][Fragments[j] - 1];	// Пропуск фрагментов через Sbox'ы
			}

			T = (Fragments[0] << 28) +						// Сборка фрагментов обратно в 32-битный подблок
				(Fragments[1] << 24) +
				(Fragments[2] << 20) +
				(Fragments[3] << 16) +
				(Fragments[4] << 12) +
				(Fragments[5] << 8) +
				(Fragments[6] << 4) +
				Fragments[7];

			T = (T << 11) | (T >> 21);						// Циклическое смещение влево на 11 бит
			T ^= B;											// XOR с B

			if (i != 31)
			{
				B = A;										// Перестановка подблоков 1-31 и 32 циклов
				A = T;
			}
			else
			{
				B = T;
			}
		}
		// Конец 32 раундов
		A =                             // Реверсирование битов
			((A & 0x1) << 31) + ((A & 0x2) << 29) + ((A & 0x4) << 27) + ((A & 0x8) << 25) +
			((A & 0x10) << 23) + ((A & 0x20) << 21) + ((A & 0x40) << 19) + ((A & 0x80) << 17) +
			((A & 0x100) << 15) + ((A & 0x200) << 13) + ((A & 0x400) << 11) + ((A & 0x800) << 9) +
			((A & 0x1000) << 7) + ((A & 0x2000) << 5) + ((A & 0x4000) << 3) + ((A & 0x8000) << 1) +
			((A & 0x10000) >> 1) + ((A & 0x20000) >> 3) + ((A & 0x40000) >> 5) + ((A & 0x80000) >> 7) +
			((A & 0x100000) >> 9) + ((A & 0x200000) >> 11) + ((A & 0x400000) >> 13) + ((A & 0x800000) >> 15) +
			((A & 0x1000000) >> 17) + ((A & 0x2000000) >> 19) + ((A & 0x4000000) >> 21) + ((A & 0x8000000) >> 23) +
			((A & 0x10000000) >> 25) + ((A & 0x20000000) >> 27) + ((A & 0x40000000) >> 29) + ((A & 0x80000000) >> 31);

		B =                             // Реверсирование битов
			((B & 0x1) << 31) + ((B & 0x2) << 29) + ((B & 0x4) << 27) + ((B & 0x8) << 25) +
			((B & 0x10) << 23) + ((B & 0x20) << 21) + ((B & 0x40) << 19) + ((B & 0x80) << 17) +
			((B & 0x100) << 15) + ((B & 0x200) << 13) + ((B & 0x400) << 11) + ((B & 0x800) << 9) +
			((B & 0x1000) << 7) + ((B & 0x2000) << 5) + ((B & 0x4000) << 3) + ((B & 0x8000) << 1) +
			((B & 0x10000) >> 1) + ((B & 0x20000) >> 3) + ((B & 0x40000) >> 5) + ((B & 0x80000) >> 7) +
			((B & 0x100000) >> 9) + ((B & 0x200000) >> 11) + ((B & 0x400000) >> 13) + ((B & 0x800000) >> 15) +
			((B & 0x1000000) >> 17) + ((B & 0x2000000) >> 19) + ((B & 0x4000000) >> 21) + ((B & 0x8000000) >> 23) +
			((B & 0x10000000) >> 25) + ((B & 0x20000000) >> 27) + ((B & 0x40000000) >> 29) + ((B & 0x80000000) >> 31);

		// Вывод A и B в файл
		T = (A & 0xFF000000) >> 24; fwrite(&T, 1, 1, g);
		T = (A & 0xFF0000) >> 16;   fwrite(&T, 1, 1, g);
		T = (A & 0xFF00) >> 8;      fwrite(&T, 1, 1, g);
		T = (A & 0xFF);				fwrite(&T, 1, 1, g);

		T = (B & 0xFF000000) >> 24; fwrite(&T, 1, 1, g);
		T = (B & 0xFF0000) >> 16;   fwrite(&T, 1, 1, g);
		T = (B & 0xFF00) >> 8;      fwrite(&T, 1, 1, g);
		T = (B & 0xFF);             fwrite(&T, 1, 1, g);
	}   // Конец файла
	fclose(f);
	fclose(g);

	if (mode == CRYPT)
	{
		cout << "текст зашифр" << endl;
	}
	if (mode == DECRYPT)
	{
		cout << "текст дешифр" << endl;
	}
}

int _tmain(int argc, _TCHAR* argv[])
{
	setlocale(0, "RUS");
	cout << "1-шифр" << endl << "2 - зашифр" << endl;
	while (true)
	{
		if (_kbhit()) // слушатель нажатия на клавиатуру
		{
			switch (_getch()) // ждёт нажатия на клавишу
			{
			case 49: // Нажато "1" - шифр
				cout << endl << "начато шифр" << endl;
				GOST(CRYPT);
				break;
			case 50: // Нажато "2" - дешифр
				cout << endl << "начато дешифр" << endl;
				GOST(DECRYPT);
				break;
			}
		}
	}
	return 0;
	system("pause");
}
